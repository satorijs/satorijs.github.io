import{_ as t,z as a,m as s,ab as i}from"./chunks/framework.xAOSN7W3.js";const m=JSON.parse('{"title":"Cross Platform","description":"","frontmatter":{},"headers":[],"relativePath":"en-US/advanced/internal.md","filePath":"en-US/advanced/internal.md"}'),n={name:"en-US/advanced/internal.md"};function o(d,e,r,l,h,c){return s(),a("div",null,[...e[0]||(e[0]=[i(`<h1 id="cross-platform" tabindex="-1">Cross Platform <a class="header-anchor" href="#cross-platform" aria-label="Permalink to &quot;Cross Platform&quot;">​</a></h1><p>As a cross-platform chat protocol, Satori provides the ability to access any platform’s native interfaces. This means you can write generic code in most cases, and use native interfaces when needed to implement platform-specific functionality.</p><p>These native capabilities are collectively referred to as internal interfaces, covering APIs, events, message elements, routes, and more.</p><h2 id="platform-vs-adapter" tabindex="-1">Platform vs Adapter <a class="header-anchor" href="#platform-vs-adapter" aria-label="Permalink to &quot;Platform vs Adapter {#platform-vs-adapter}&quot;">​</a></h2><p>Most Satori APIs require the <code>Satori-Platform</code> and <code>Satori-User-ID</code> request headers, in order to distinguish the login account that initiates the request. Different platforms have different <code>login.platform</code>, while different accounts on the same platform have different <code>login.user.id</code>. With this mechanism, safe isolation is achieved.</p><p>For most chat platforms, the <code>platform</code> field is a fixed value set directly by SDKs. However, for platforms that can be self-hosted (e.g. Rocket Chat and Zulip), SDKs usually need the deployer to configure <code>platform</code> to differentiate between different servers. If mixed directly, this may cause issues such as data collisions.</p><p>Therefore, for any Login, there are actually two different concepts:</p><ul><li><code>login.platform</code>: chat platform. Usually, users within the same platform can message each other, while users across different platforms cannot. In Satori, <code>platform</code> also acts as a namespace, so SDKs must ensure the uniqueness of <code>user.id</code>, <code>guild.id</code>, etc. within the same <code>platform</code>.</li><li><code>login.adapter</code>: adapter. This is more of an implementation concept: it determines how the platform is communicated with. Under the same adapter, there are usually the same extended APIs, events, and message elements. This field is typically set directly by SDKs, and developers can use it to determine whether the implementation supports certain features.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>If you still find it hard to distinguish <code>platform</code> and <code>adapter</code>, remember:</p><ul><li>IDs are compatible within the same <code>platform</code>;</li><li>APIs are compatible within the same <code>adapter</code>.</li></ul><p>These two conditions are sufficient but not necessary. In other words, even if two Logins have compatible IDs or APIs, they may still use different <code>platform</code> or <code>adapter</code>. This depends entirely on SDK implementation and community conventions.</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Note that these two concepts are actually many-to-many. Some special scenarios:</p><ul><li><strong>Single adapter, multiple platforms</strong>: a platform allows self-hosting. Two independent self-hosted servers have different data; all <code>user.id</code>, <code>guild.id</code>, etc. belong to different namespaces, so <code>platform</code> should be different. But they use the same communication method, so <code>adapter</code> should be the same.</li><li><strong>Single platform, multiple adapters</strong>: a platform has both official and unofficial SDKs, and the two SDKs use different communication methods, so <code>adapter</code> should be different. But they both target the same platform; all <code>user.id</code>, <code>guild.id</code>, etc. belong to the same namespace, so <code>platform</code> should be the same.</li></ul></div><h2 id="api" tabindex="-1">API Extensions <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API Extensions {#api}&quot;">​</a></h2><p>SDKs can proxy platform-native APIs via the route <code>/{version}/internal/{method}</code>.</p><p>For example, Discord provides a RESTful API, so you can make a request like:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>DELETE /v1/internal/channels/111222333</span></span>
<span class="line"><span>Satori-Platform: discord</span></span>
<span class="line"><span>Satori-User-ID: 1234567890</span></span></code></pre></div><p>Except for the prefixed route and the additional <code>Satori-Platform</code> and <code>Satori-User-ID</code> headers, the request and response formats are identical to the platform’s native API.</p><h2 id="events" tabindex="-1">Event Extensions <a class="header-anchor" href="#events" aria-label="Permalink to &quot;Event Extensions {#events}&quot;">​</a></h2><h3 id="platform-native-events" tabindex="-1">Platform-native Events <a class="header-anchor" href="#platform-native-events" aria-label="Permalink to &quot;Platform-native Events&quot;">​</a></h3><p>SDKs can proxy platform-native events through the <code>_type</code> and <code>_data</code> fields of the <code>internal</code> event. Its structure is:</p><table tabindex="0"><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>sn</code></td><td>number</td><td>Event sequence number</td></tr><tr><td><code>type</code></td><td>string</td><td>Event type (fixed as <code>internal</code>)</td></tr><tr><td><code>login</code></td><td><a href="./../resources/login.html">Login</a></td><td>Login info</td></tr><tr><td><code>_type</code></td><td>string</td><td>Native event type</td></tr><tr><td><code>_data</code></td><td>object</td><td>Native event payload</td></tr></tbody></table><h3 id="extension-fields-on-standard-events" tabindex="-1">Extension Fields on Standard Events <a class="header-anchor" href="#extension-fields-on-standard-events" aria-label="Permalink to &quot;Extension Fields on Standard Events&quot;">​</a></h3><p>Platform-native fields for standard events can also be accessed via <code>_type</code> and <code>_data</code>. Its structure is:</p><table tabindex="0"><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></td><td>string</td><td>Event type (should not be <code>internal</code>)</td></tr><tr><td><code>_type</code></td><td>string</td><td>Platform-generic name</td></tr><tr><td><code>_data</code></td><td>object</td><td>Native event payload</td></tr><tr><td>other fields</td><td></td><td>Other standard event fields</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Some platform-native events can map directly to standard events. When such events are triggered, SDKs may emit both a standard event and a platform-native event. Both events include <code>_type</code> and <code>_data</code>, but their values may differ.</p></div><h2 id="elements" tabindex="-1">Message Element Extensions <a class="header-anchor" href="#elements" aria-label="Permalink to &quot;Message Element Extensions {#elements}&quot;">​</a></h2><h3 id="platform-native-message-elements" tabindex="-1">Platform-native Message Elements <a class="header-anchor" href="#platform-native-message-elements" aria-label="Permalink to &quot;Platform-native Message Elements&quot;">​</a></h3><p>Platforms may provide native message elements, but they must be prefixed with the adapter name. For example:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:inherit;">kook:card</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;lg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:inherit;">kook:countdown</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> end-time</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;1608819168000&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#E06C75;--shiki-dark-font-style:inherit;">kook:card</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><h3 id="extension-attributes-on-standard-elements" tabindex="-1">Extension Attributes on Standard Elements <a class="header-anchor" href="#extension-attributes-on-standard-elements" aria-label="Permalink to &quot;Extension Attributes on Standard Elements&quot;">​</a></h3><p>Platform-native attributes for standard elements can also be declared by prefixing them with the adapter name. For example:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- src is a standard attribute of the audio element. --&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- cover is not standardized, so it needs a prefix. --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">audio</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;url1&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> kook:cover</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;url2&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FFFFFF;--shiki-dark-font-style:inherit;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Whether attributes on platform-native message elements need a prefix is up to SDK implementation. If a message element is likely to be standardized in the future, adding a prefix can reduce migration cost. If standardization is not needed, omitting the prefix is more convenient to write.</p></div>`,31)])])}const f=t(n,[["render",o]]);export{m as __pageData,f as default};
