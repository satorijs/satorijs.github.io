import{_ as i,y as n,aa as a,p as e,z as o,l as s,X as d,R as l,j as h}from"./chunks/framework.CIYb0pjC.js";const v=JSON.parse('{"title":"用户 (User)","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/resources/user.md","filePath":"zh-CN/resources/user.md"}'),u={name:"zh-CN/resources/user.md"},p={class:"route"},b={class:"route"},f={class:"route"};function c(m,t,k,q,g,x){const r=l("badge");return h(),n("div",null,[t[9]||(t[9]=a('<h1 id="用户" tabindex="-1">用户 (User) <a class="header-anchor" href="#用户" aria-label="Permalink to &quot;用户 (User)&quot;">​</a></h1><h2 id="类型定义" tabindex="-1">类型定义 <a class="header-anchor" href="#类型定义" aria-label="Permalink to &quot;类型定义&quot;">​</a></h2><h3 id="def-user" tabindex="-1">User <a class="header-anchor" href="#def-user" aria-label="Permalink to &quot;User {#def-user}&quot;">​</a></h3><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>string</td><td>用户 ID</td></tr><tr><td>name</td><td>string?</td><td>用户名称<sup><a href="#name-nick">[1]</a></sup></td></tr><tr><td>nick</td><td>string?</td><td>用户昵称<sup><a href="#name-nick">[1]</a></sup></td></tr><tr><td>avatar</td><td>string?</td><td>用户头像链接</td></tr><tr><td>is_bot</td><td>boolean?</td><td>是否为机器人</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p id="name-nick"><strong>[1] <code>name</code> 和 <code>nick</code> 字段的区别</strong></p><p>这两个字段都可以用于标识用户。在一些平台上 (例如 Telegram)，一个用户存在多种不同概念的名称，因此 SDK 可以同时设置这两个字段。而另一些平台可能不存在这两个概念的对立关系，此时 SDK 只需要根据语义设置 <code>name</code> 或 <code>nick</code> 中的一个即可。</p><p>在应用层实现上，<code>nick</code> 的优先级高于 <code>name</code>，因为昵称更容易被用户识别和理解。如果你正在开发基于 Satori 协议的客户端，在用户名的显示上应当优先使用 <code>nick</code> 字段，只有当 <code>nick</code> 为空时才使用 <code>name</code> 字段。</p></div><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h2><h3 id="api-user-get" tabindex="-1">获取用户信息 <a class="header-anchor" href="#api-user-get" aria-label="Permalink to &quot;获取用户信息 {#api-user-get}&quot;">​</a></h3>',7)),e("blockquote",p,[o(r,null,{default:s(()=>t[0]||(t[0]=[d("POST")])),_:1}),t[1]||(t[1]=d()),t[2]||(t[2]=e("code",null,"/user.get",-1))]),t[10]||(t[10]=a('<table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>user_id</td><td>string</td><td>用户 ID</td></tr></tbody></table><p>获取用户信息。返回一个 <a href="#def-user"><code>User</code></a> 对象。</p><h3 id="api-friend-list" tabindex="-1">获取好友列表 <a class="header-anchor" href="#api-friend-list" aria-label="Permalink to &quot;获取好友列表 {#api-friend-list}&quot;">​</a></h3>',3)),e("blockquote",b,[o(r,null,{default:s(()=>t[3]||(t[3]=[d("POST")])),_:1}),t[4]||(t[4]=d()),t[5]||(t[5]=e("code",null,"/friend.list",-1))]),t[11]||(t[11]=a('<table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>next</td><td>string?</td><td>分页令牌</td></tr></tbody></table><p>获取好友列表。返回一个 <a href="#def-user"><code>User</code></a> 的 <a href="./../protocol/api.html#list">分页列表</a>。</p><h3 id="api-friend-approve" tabindex="-1">处理好友申请 <a class="header-anchor" href="#api-friend-approve" aria-label="Permalink to &quot;处理好友申请 {#api-friend-approve}&quot;">​</a></h3>',3)),e("blockquote",f,[o(r,null,{default:s(()=>t[6]||(t[6]=[d("POST")])),_:1}),t[7]||(t[7]=d()),t[8]||(t[8]=e("code",null,"/friend.approve",-1))]),t[12]||(t[12]=a('<table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>message_id</td><td>string</td><td>请求 ID</td></tr><tr><td>approve</td><td>boolean</td><td>是否通过请求</td></tr><tr><td>comment</td><td>string?</td><td>备注信息</td></tr></tbody></table><p>处理好友申请。</p><h2 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h2><h3 id="friend-request" tabindex="-1">friend-request <a class="header-anchor" href="#friend-request" aria-label="Permalink to &quot;friend-request&quot;">​</a></h3><p>接收到新的好友申请时触发。必需资源：<a href="#def-user"><code>user</code></a>。</p>',5))])}const y=i(u,[["render",c]]);export{v as __pageData,y as default};
