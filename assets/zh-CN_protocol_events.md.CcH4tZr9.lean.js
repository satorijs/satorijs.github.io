import{_ as n,y as s,aa as r,p as e,X as d,z as a,l,R as i,j as u}from"./chunks/framework.CIYb0pjC.js";const y=JSON.parse('{"title":"事件","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/protocol/events.md","filePath":"zh-CN/protocol/events.md"}'),h={name:"zh-CN/protocol/events.md"},c={tabindex:"0"},b={id:"webhook",tabindex:"-1"};function p(m,t,f,g,k,S){const o=i("badge");return u(),s("div",null,[t[17]||(t[17]=r('<h1 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h1><p>Satori 协议规定了两套事件服务，分别基于 WebSocket 和 WebHook。</p><h2 id="类型定义" tabindex="-1">类型定义 <a class="header-anchor" href="#类型定义" aria-label="Permalink to &quot;类型定义&quot;">​</a></h2><h3 id="opcode" tabindex="-1">Opcode <a class="header-anchor" href="#opcode" aria-label="Permalink to &quot;Opcode&quot;">​</a></h3>',4)),e("table",c,[t[10]||(t[10]=e("thead",null,[e("tr",null,[e("th",null,"名称"),e("th",null,"值"),e("th",null,"方向"),e("th",null,"描述")])],-1)),e("tbody",null,[t[5]||(t[5]=e("tr",null,[e("td",null,"EVENT"),e("td",null,"0"),e("td",null,"接收"),e("td",null,"事件")],-1)),t[6]||(t[6]=e("tr",null,[e("td",null,"PING"),e("td",null,"1"),e("td",null,"发送"),e("td",null,"心跳")],-1)),t[7]||(t[7]=e("tr",null,[e("td",null,"PONG"),e("td",null,"2"),e("td",null,"接收"),e("td",null,"心跳回复")],-1)),t[8]||(t[8]=e("tr",null,[e("td",null,"IDENTIFY"),e("td",null,"3"),e("td",null,"发送"),e("td",null,"鉴权")],-1)),t[9]||(t[9]=e("tr",null,[e("td",null,"READY"),e("td",null,"4"),e("td",null,"接收"),e("td",null,"鉴权成功")],-1)),e("tr",null,[t[2]||(t[2]=e("td",null,"META",-1)),t[3]||(t[3]=e("td",null,"5",-1)),t[4]||(t[4]=e("td",null,"接收",-1)),e("td",null,[t[1]||(t[1]=d("元信息更新 ")),a(o,{type:"warning"},{default:l(()=>t[0]||(t[0]=[d("实验性")])),_:1})])])])]),t[18]||(t[18]=r('<h3 id="event" tabindex="-1">Event <a class="header-anchor" href="#event" aria-label="Permalink to &quot;Event&quot;">​</a></h3><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>sn</td><td>number</td><td>序列号</td></tr><tr><td>type</td><td>string</td><td>事件类型</td></tr><tr><td>timestamp</td><td>number</td><td>事件的时间戳</td></tr><tr><td>login</td><td><a href="./../resources/login.html#def-login">Login</a></td><td>登录信息</td></tr><tr><td>argv</td><td><a href="./../resources/interaction.html#def-argv">Argv</a>?</td><td>交互指令</td></tr><tr><td>button</td><td><a href="./../resources/interaction.html#def-button">Button</a>?</td><td>交互按钮</td></tr><tr><td>channel</td><td><a href="./../resources/channel.html#def-channel">Channel</a>?</td><td>事件所属的频道</td></tr><tr><td>guild</td><td><a href="./../resources/guild.html#def-guild">Guild</a>?</td><td>事件所属的群组</td></tr><tr><td>member</td><td><a href="./../resources/member.html#def-guild-member">GuildMember</a>?</td><td>事件的目标成员</td></tr><tr><td>message</td><td><a href="./../resources/message.html#def-message">Message</a>?</td><td>事件的消息</td></tr><tr><td>operator</td><td><a href="./../resources/user.html#def-user">User</a>?</td><td>事件的操作者</td></tr><tr><td>role</td><td><a href="./../resources/role.html#def-guild-role">GuildRole</a>?</td><td>事件的目标角色</td></tr><tr><td>user</td><td><a href="./../resources/user.html#def-user">User</a>?</td><td>事件的目标用户</td></tr></tbody></table><p>事件分为登录事件与非登录事件，其中登录事件特指与 Login 变化相关的事件 (如 <a href="./../resources/login.html#login-added">login-added</a>)。所有事件都采用上述数据结构，不过在细节上有所区别：</p><ul><li>非登录事件中的 <code>login</code> 资源只会带有 <code>sn</code>, <code>user</code> 和 <code>platform</code> 三个属性；</li><li>非登录事件均确保 <code>login.status</code> 为 <code>ONLINE</code> (尽管不会传递这个字段）；</li><li>登录事件会带有完整的 <code>login</code> 资源，但可能不存在 <code>user</code> 和 <code>platform</code>；</li><li>登录事件不参与 <a href="#session-recovery">会话恢复</a>。</li></ul><p>事件中的各属性遵循 <a href="./">资源提升</a> 规则。</p><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;WebSocket&quot;">​</a></h2><p>WebSocket 服务用于在 Satori SDK 与应用之间维护一个持久的、有状态的链接。通过这个链接，Satori 应用可以实时接收 SDK 推送的事件。</p><p>WebSocket 服务的地址为 <code>/{path}/{version}/events</code>。其中，<code>path</code> 为部署路径 (可以为空)，<code>version</code> 为 API 的版本号。</p><p>目前 Satori 仅有 v1 一个版本。</p><h3 id="连接流程" tabindex="-1">连接流程 <a class="header-anchor" href="#连接流程" aria-label="Permalink to &quot;连接流程&quot;">​</a></h3><p>总的来说，Satori 应用需要在连接后遵循以下步骤：</p><ol><li>连接建立后，在 10s 内发送一个 <code>IDENTIFY</code> 信令，用于鉴权和恢复会话；<br>SDK 收到后会回复一个 <code>READY</code> 信令，并开启事件推送；</li><li>连接建立后，每隔 10s 向 SDK 发送一次 <code>PING</code> 信令；<br>SDK 收到后会回复一个 <code>PONG</code> 信令；</li><li>应用持续接收来自 SDK 的 <code>EVENT</code> 信令，用于接收事件。</li></ol><p>信令的数据结构如下：</p><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>op</td><td><a href="#opcode">Opcode</a></td><td>信令类型</td></tr><tr><td>body</td><td>object?</td><td>信令数据</td></tr></tbody></table><p><code>IDENTIFY</code> 信令的 <code>body</code> 数据结构如下：</p><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>token</td><td>string?</td><td>鉴权令牌</td></tr><tr><td>sn</td><td>number?</td><td>序列号</td></tr></tbody></table><p><code>READY</code> 信令的 <code>body</code> 数据结构如下：</p><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>logins</td><td><a href="./../resources/login.html#def-login">Login</a>[]</td><td>登录信息</td></tr><tr><td>proxy_urls</td><td>string[]</td><td><a href="./../advanced/resource.html#proxy-route">代理路由</a> 列表</td></tr></tbody></table><p><code>META</code> 信令的 <code>body</code> 数据结构如下：</p><table tabindex="0"><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>proxy_urls</td><td>string[]</td><td><a href="./../advanced/resource.html#proxy-route">代理路由</a> 列表</td></tr></tbody></table><p><code>EVENT</code> 信令的 <code>body</code> 数据结构参见 <a href="#event">Event</a>。</p><h3 id="鉴权" tabindex="-1">鉴权 <a class="header-anchor" href="#鉴权" aria-label="Permalink to &quot;鉴权&quot;">​</a></h3><p>WebSocket 鉴权通过 <code>IDENTIFY</code> 信令的 <code>token</code> 字段来实现。其中涉及的鉴权令牌由 SDK 分发，本协议不做任何限制。</p><p>如果 SDK 没有配置鉴权，则应用无需提供上述字段。</p><h3 id="session-recovery" tabindex="-1">会话恢复 <a class="header-anchor" href="#session-recovery" aria-label="Permalink to &quot;会话恢复 {#session-recovery}&quot;">​</a></h3><p>当连接短暂中断时，Satori 应用可以通过 <code>IDENTIFY</code> 信令的 <code>sn</code> 字段来恢复会话。<code>sn</code> 字段的值为上一次连接中最后一个接收到的 <code>EVENT</code> 信令的 <code>sn</code> 字段。会话恢复后，SDK 会向应用推送所有在断开连接期间发生的事件。</p><p>登录事件将不会在会话恢复过程中推送，因为在 <code>READY</code> 信令中已经包含了最新的登录状态。</p>',27)),e("h2",b,[t[13]||(t[13]=d("WebHook ")),a(o,null,{default:l(()=>t[11]||(t[11]=[d("可选")])),_:1}),t[14]||(t[14]=d()),a(o,{type:"warning"},{default:l(()=>t[12]||(t[12]=[d("实验性")])),_:1}),t[15]||(t[15]=d()),t[16]||(t[16]=e("a",{class:"header-anchor",href:"#webhook","aria-label":'Permalink to "WebHook <badge>可选</badge> <badge type="warning">实验性</badge>"'},"​",-1))]),t[19]||(t[19]=r('<div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这是一个可选功能。</p></div><p>WebHook 服务是指，Satori SDK 在接收到平台事件时，向应用提供的 HTTP 地址推送事件。一个 SDK 应当可以配置多个 WebHook，并允许应用对发送者进行鉴权。这些 WebHook 的配置方式由 SDK 自身决定，本协议仅规范化了一组 <a href="./../advanced/meta.html#api">API</a>，不做强制要求。</p><p>事件推送以 POST 的形式进行。请求头包含 <code>Satori-Opcode</code> 字段，对应本次推送的 <a href="#opcode">信令类型</a>；请求体是一个 JSON 对象，对应本次推送的信令数据。例如，一次事件推送将会拥有 <code>Satori-Opcode: 0</code> 的请求头，以及一个符合 <a href="#event">Event</a> 结构的请求体。</p><p>WebHook 所涉及的信令仅包含 <code>EVENT</code>, <code>META</code> 两种。</p><p>应用收到 WebHook 请求时，如果能够顺利鉴权并处理请求，应当返回 2XX 的状态码。如果鉴权失败，应当返回 4XX 的状态码。如果处理失败，应当返回 5XX 的状态码。</p><h3 id="反向鉴权" tabindex="-1">反向鉴权 <a class="header-anchor" href="#反向鉴权" aria-label="Permalink to &quot;反向鉴权&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这里的鉴权与 API 与 WebSocket 中的鉴权逻辑类似，但方向相反。</p></div><p>Satori 应用可以要求 SDK 在发送 WebHook 请求时附带一个 <code>Authorization</code> 请求头，格式为 <code>Bearer {token}</code>。其中，<code>token</code> 由应用进行分发。</p>',8))])}const E=n(h,[["render",p]]);export{y as __pageData,E as default};
